// TODO: free variables refer to names in the global environment.
// TODO: apply, 

[[getValue]] = func (x) {
  return if (typeof x === "location") { !x } else { x }
}

/* Algorithm 9.9 of ECMA-262, ed. 3.  if given an object, expects it to
  be a (ERef (EObject)) it itself returns Refs */
[[toObject]] = func (x) {
  return if (typeof x === "undefined") {
    throw "TypeError: toObject received undefined"
  }
  else if (typeof x === "null") {
    throw "TypeError: toObject received null"
  }
  else if (typeof x === "boolean") {
    ref { __proto__ : "Boolean.prototype",
         __class__ : "Boolean",
         __value__ : x }
  }
  else if (typeof x === "number") {
    ref { __proto__ : "Number.prototype",
         __class__ : "Number",
         __value__ : x }
  }
  else if (typeof x === "string") {
    ref { __proto__ : "String.prototype",
         __class__ : "String",
         __value__ : x }
  }
  else {
    x
  }
}

/* Even though GetValue'd values are given to ToPrimitive in ECMA, here
 we need ERefs because we will apply functions.  So make sure you give
 this ERef (EObject) if you get an object.  */
[[toPrimitive_valueOf]] = func (x, cont) {
  return
    let (valueOf = (!x)["valueOf"])
      if (typeof valueof === "location" && 
          typeof !valueOf === "object" &&
          typeof (!valueOf)["__lambda__"] === "function") {
        let (result = apply(valueOf, x, { }))
          if (prim("primitive?", result)) result
          else cont()
      }
      else {
        cont()
      }
}

[[toPrimitive_toString]] = func (x, cont) { return
  let (toString = (!x)["toString"])
    if (typeof toString === "location" && 
        typeof !toString === "object" &&
        typeof (!toString)["__lambda__"] === "function")
      let (result = apply(toString, x, { }))
         if (prim("primitive?", result))
           result
         else 
           cont()
    else
      cont()
}

[[toPrimitive_String]] = func(x) {
  return toPrimitive_toString(x, func() {
    return toPrimitive_valueOf(x, func() {
      return throw "TypeError: cannot convert object to primitive"
      })
  })
}

[[toPrimitive_Number]] = func(x) {
  return toPrimitive_valueOf(x, func() {
    return toPrimitive_toString(x, func() {
      return throw "TypeError: cannot convert object to primitive"
      })
  })
}


[[toPrimitive]] = toPrimitive_Number

// ECMA 9.3 once again, must get object refs to pass them in as this in
// toPrimitive
[[toNumber]] = func(x) {
  return prim("prim->num",
    if (typeof x === "location") { toPrimitive_Number(x) }
    else { x })

}

/* Algorithm 9.8 expects objects to be locations to be able to call
  toPrimitive.  otherwise it should be a value. */
[[toString]] = func(x) {
  return prim("prim->str", 
    if (typeof x === "location") { toPrimitive_Number(x) }
    else { x })
}

[[abstractEquality]] = func(lhs, rhs) {
  return if (prim("abstract=", lhs, rhs)) {
    true
  }
  else if (typeof lhs === "location") {
     prim("abstract=", toPrimitive(lhs), rhs)
  }
  else if (typeof rhs === "location") {
     prim("abstract=", lhs, toPrimitive(rhs))
  }
  else {
    false
  }
}
