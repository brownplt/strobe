// TODO: free variables refer to names in the global environment.
// TODO: apply, 

[[getValue]] = func (x) {
  return if (typeof x === "location") { !x } else { x }
}

/* Algorithm 9.9 of ECMA-262, ed. 3.  if given an object, expects it to
  be a (ERef (EObject)) it itself returns Refs */
[[toObject]] = func (x) {
  return if (typeof x === "undefined") {
    throw "TypeError: toObject received undefined"
  }
  else if (typeof x === "null") {
    throw "TypeError: toObject received null"
  }
  else if (typeof x === "boolean") {
    ref { __proto__ : "Boolean.prototype",
         __class__ : "Boolean",
         __value__ : x }
  }
  else if (typeof x === "number") {
    ref { __proto__ : "Number.prototype",
         __class__ : "Number",
         __value__ : x }
  }
  else if (typeof x === "string") {
    ref { __proto__ : "String.prototype",
         __class__ : "String",
         __value__ : x }
  }
  else {
    x
  }
}

/* Even though GetValue'd values are given to ToPrimitive in ECMA, here
 we need ERefs because we will apply functions.  So make sure you give
 this ERef (EObject) if you get an object.  */
[[toPrimitive_valueOf]] = func (x, cont) {
  return
    let (valueOf = (!x)["valueOf"])
      if (typeof valueOf === "location" && 
          typeof !valueOf === "object" &&
          typeof (!valueOf)["__lambda__"] === "function") {
        let (result = apply(valueOf, x, { }))
          if (prim("primitive?", result)) result
          else cont()
      }
      else {
        cont()
      }
}

[[toPrimitive_toString]] = func (x, cont) { return
  let (toString = (!x)["toString"])
    if (typeof toString === "location" && 
        typeof !toString === "object" &&
        typeof (!toString)["__lambda__"] === "function")
      let (result = apply(toString, x, { }))
         if (prim("primitive?", result))
           result
         else 
           cont()
    else
      cont()
}

[[toPrimitive_String]] = func(x) {
  return toPrimitive_toString(x, func() {
    return toPrimitive_valueOf(x, func() {
      return throw "TypeError: cannot convert object to primitive"
      })
  })
}

[[toPrimitive_Number]] = func(x) {
  return toPrimitive_valueOf(x, func() {
    return toPrimitive_toString(x, func() {
      return throw "TypeError: cannot convert object to primitive"
      })
  })
}


// A deficiency of our CPSer--it requires all bindings in a Fix to be syntactic
// lambdas.
[[toPrimitive]] = func(x) { return toPrimitive_Number(x) }

// ECMA 9.3 once again, must get object refs to pass them in as this in
// toPrimitive
[[toNumber]] = func(x) {
  return prim("prim->num",
    if (typeof x === "location") { toPrimitive_Number(x) }
    else { x })

}

/* Algorithm 9.8 expects objects to be locations to be able to call
  toPrimitive.  otherwise it should be a value. */
[[toString]] = func(x) {
  return prim("prim->str", 
    if (typeof x === "location") { toPrimitive_Number(x) }
    else { x })
}

[[abstractEquality]] = func(lhs, rhs) {
  return if (prim("abstract=", lhs, rhs)) {
    true
  }
  else if (typeof lhs === "location") {
     prim("abstract=", toPrimitive(lhs), rhs)
  }
  else if (typeof rhs === "location") {
     prim("abstract=", lhs, toPrimitive(rhs))
  }
  else {
    false
  }
}

// Not all properties can be deleted. However, there aren't that many, so
// we don't bother DontDelete in \JS.
[[safeDelete]] = func(obj, field) {
  return
    let (f_string = toString(field))
    if (prim("obj-can-delete?", !obj, f_string)) {
      obj := !obj[delete f_string];
      true
    }
    else {
      false
    }
}

[[inOperator]] = func(prop, obj) { 
  return 
    if (prim("has-own-property?", obj, prop)) {
      true
    }
    else if (prim("has-own-property?", !obj, "__proto__") &&
             !obj["__proto__"] !== null) {
      inOperator(prop, !obj["__proto__"])
    }
    else {
      false
   }
}

// 11.8.6, 15.3.5.3
[[instanceofRec]] = func(obj, constr) {
  return if (typeof obj === "location" && typeof !obj === "object") {
    if (!obj["__proto__"] === !constr["prototype"]) {
      true
    }
    else {
      instanceofRec(!obj["__proto__"], constr)
    }
  }
  else {
    false
  }
}

[[instanceofOperator]] = func (obj, constr) {
  return
    if (prim("has-own-property?", !constr, "__code__")) {
      throw newError("TypeError", "instanceof args of wrong type")
    }
   else {
     instanceofRec(obj, constr)
   }
}